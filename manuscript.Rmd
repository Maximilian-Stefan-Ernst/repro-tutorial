---
title: A Hitchhiker's Guide to Reproducible Research in R
author:
  - name: Aaron Peikert
    affil: 1, *
    orcid: 0000-0001-7813-818X
  - name: Caspar J. Van Lissa
    affil: 2, 3
    orcid: 0000-0002-0808-5024
  - name: Andreas M. Brandmaier
    affil: 1, 4
    orcid: 0000-0001-8765-6982
affiliation:
  - num: 1
    address: |
      Center for Lifespan Psychology---Max Planck Institute for Human Development
      Lentzeallee 94, 14195 Berlin, Germany
  - num: 2
    address: |
      Department of Methodology & Statistics---Utrecht University faculty of Social and Behavioral Sciences, Utrecht, Netherlands
  - num: 3
    address: |
      Open Science Community Utrecht, Utrecht, Netherlands
  - num: 4
    address: |
      Max Planck UCL Centre for Computational Psychiatry and Ageing Research
      Berlin, Germany and London, UK
# firstnote to eighthnote
correspondence: |
  peikert@mpib-berlin.mpg.de
journal: psych
type: tutorial
status: submit
bibliography: temp.bib
simplesummary: |
  A Simple summary goes here.
abstract: "`r tryCatch(trimws(readr::read_file(here::here('abstract.Rmd'))))`"
keywords: |
  keyword 1; keyword 2; keyword 3 (list three to ten pertinent keywords specific 
  to the article, yet reasonably common within the subject discipline.).
acknowledgement: |
  The authors received no financial support for the research, authorship, and/or publication of this article.
authorcontributions: |
  Aaron Peikert took the lead in writing and provided the initial draft of the manuscript.
  Andreas Brandmaier and Caspar J. Van Lissa contributed further ideas, critical feedback, and revisions of the original manuscript.
  Furthermore, we would like to thank Maximilian Stefan Ernst (not an author) for his contributions to the code for the simulation study.
conflictsofinterest: |
  The authors declare no conflict of interest.
abbreviations:
  - short: PAC
    long: Preregistration as 
  - short: Gb
    long: Gigabyte
  - short: Kb
    long: Kilobyte
  - short: GUI
    long: Graphical User Interface
  - short: CLI
    long: Comand Line Interface
  - short: CRAN
    long: Comprehensive R Archive Network
repro:
  packages:
    - tidyverse
    - usethis
    - gert
    - aaronpeikert/repro@7bfaf98
    - here
    - rstudio/webshot2@f62e743
    - targets
    - renv
    - slider
    - patchwork
    - knitr
    - pander
    - lavaan
    - furrr
    - future.batchtools
    - rticles
    - moments
    - report
  scripts:
    - R/simulation.R
    - R/simulation_funs.R
    - R/link.R
  data:
    - data/simulation_results.csv
output:
  bookdown::markdown_document2:
    base_format: rticles::mdpi_article
header-includes:
   - \usepackage[labelformat=empty]{caption}
   - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}, numbers=left}
---

```{r setup, include=FALSE}
library(repro)
automate_load_packages()
automate_load_scripts()
source(here::here("R", "link.R"))
```

```{r echo=FALSE}
# define a print method for objects of the class data.frame
knit_print.data.frame = function(x, ...) {
  res = paste(c('', '', kable(x)), collapse = '\n')
  asis_output(res)
}
# register the method
registerS3method("knit_print", "data.frame", knit_print.data.frame)
```

# Introduction

Increasingly, scientists make their data, materials, and analysis code openly available.
Sharing all these types of digital research output increases scientific efficiency by enabling researchers to learn from each other, reuse materials, or review published research results, but only if these artifacts are reproducible.
We now have the technology to make all artefacts related to a research project available so that a research project can be reproduced with minimal effort.
Reproducibility has long been considered integral to empirical research, whose credibility hinges on its objectivity, meaning "in principle it can be tested and understood by anybody." [@popperLogicScientificDiscovery2002, p. 22][^popper]
Reproducibility can be defined as the ability of anyone to obtain identical results from the *same* data with the *same* computer code [see @Peikert2019 for details].
Unfortunately, despite increasing commitment to open science practices and good will, many projects can not yet be reproduced by other research teams [@obels2020].
This is because making a research project with all code, data, and materials reproducible comes with a variety of challenges, and there is a dire need for reproducibility standards.

This tutorial is aimed at researchers who intend to ensure the reproducibility of a research project and are willing to make relevant code, data, and materials available, whether publicly or on request.
We pursue two aims.
First, the present paper introduces the reader to a workflow that ensures reproducibility by building on several technical solutions originating in the software engineering community that eliminate four common threats to reproducibility [see @Peikert2019 for details].
Specifically, we demonstrate how the R package `repro` supports researchers in implementing these solutions.
The second objective is to discuss opportunities of such workflows to improve not only how research outputs are created and recreated but also how research itself is conducted.
One such opportunity is an alternative preregistration <!--AP preregistration is not explained yet; citation?--> scheme that builds upon a reproducible workflow, the so-called _preregistration as code_ (PAC), where the researchers write the complete analysis as code and the bulk of the manuscript as dynamic document, including the sections Introduction, Methods, and Results before they gather empirical data.
This dynamic document closely resembles an actual journal article but with "fake" results from simulated data that serve to generate placeholders for figures, tables, and statistics. 
This document serves as unambiguous preregistration of the planned analysis and how the results are going to be reported.
The only parts that are missing from this first draft are the discussion of results, which will completed once the real data were gathered.

[^popper]: In fact, @popperLogicScientificDiscovery2002's famous criterion of demarcation is built around "inter-subjective testing", a concept which he later generalised to inter-subjective criticism (Footnote *1, p. 22). Somewhat confusingly, @popperLogicScientificDiscovery2002 uses the term "Reproducibility" for what we would call "Replication".

While the willingness to share materials is required for reproducing a project, it is not sufficient to achieve it.
For example, @hardwicke2018 attempted to reproduce results from open materials in the journal Cognition. 
Out of 35 published articles, results of 22 articles could be reproduced but in 11 of these cases, assistance from the original authors was required.
For 13 articles, at least one outcome could not be reproducedâ€”--even with the original authors' assistance.
@obels2020 showed that in 62 Registered Reports, 41 had data available, and 37 had analysis scripts available.
The authors could execute only 31 of the scripts without error and reproduce the results of only 21 articles (within a reasonable time).
These failed attempts to reproduce highlight the need for widely accepted reproducibility standards, because open repositories do not routinely provide sufficient information to reproduce relevant computational and statistical results.

We argue that the benefits of open science increase if research is not only transparent but reproducible.
To this end, this tutorial demonstrates how to make R-based research projects reproducible, while striking a balance between rigor and ease-of-use.
A rigorous standard increases the likelihood of any individual project to be actually reproducible and remain reproducible as long as possible.
An easy-to-use standard, on the other hand, is less error-prone, produces less overhead and is thus more likely to be adopted.
To us, it makes sense to strive for a broad adoption of easy-to-use practices and then gradually move into more rigorous standards as researchers become more proficient with the tools involved.
The remainder of this paper is structured along these lines.
The first part introduces theoretical concepts and software solutions that together form a rigorous reproducibility standard.
The second part is a tutorial that shows how these software solutions can be easily employed by researchers with the help of the R package `repro`.

We have structured the tutorial with a _learning by doing_ approach in mind, such that readers can follow along on their own computers.
We explicitly encourage readers to try out all R commands for themselves.
Unless stated otherwise, all code blocks are meant to be run in the statistical programming language R (tested with version `r with(R.version, paste0(major, ".", minor))`).

# Concepts and Software Solutions

From our own experience with various research projects, we identified the following common threats to reproducibility: <!-- CJ How did you identify these causes? Is this exhaustive?-->

1.	**Multiple inconsistent versions of code, data, or both**; for example, the data set could have changed over time because outliers were removed at a later stage or an item was later recoded; or the analysis code could have been modified during writing of a paper because a bug was removed at some point in time; it may then be unclear, which version of code and data was used to produce some reported set of results.
2.	**Copy-and-paste errors**; for example, often, results are manually copied from a statistical computing language into a text processor; if a given analysis is re-run and results are manually updated in the text processor, this may inadvertently lead to inconsistencies between the reported result and the reproduced result;
3.	**Undocumented or ambiguous order of code execution**; for example, with multiple data and code files, it may be unclear which scripts should be executed in what order;  or, some of the computational steps are documented (e.g., final analysis), but other steps were conducted manually and not documented (e.g., copy-pasting results from one program to another; reverse coding items on the fly)
4.	**External code dependencies**; for example, a given analysis may depend on a specific version of a specific software package that might not be available on a different computer or no longer exist at all; or, a different version of the same software may produce different results.
<!-- CJ 5. Missing steps: Some of the steps are documented (e.g., final analysis), but other steps were conducted manually and not documented (e.g., copy-pasting results from one program to another; reverse coding items on the fly).-->
<!--AB Caspar's 5th point is important. In my mind, this best fits to point #3, which adressed an insufficient level of coding/automation/documentation of the necessary steps taken. Can we merge this into one new point #3? I will commit a suggested change of point #3 here (see above);.-->

We have developed a workflow that leverages established tools and practices from software engineering to achieve long-term and cross-platform computational reproducibility of scientific data analyses resting on four pillars that address the aforementioned causes of non-reproducibility [@Peikert2019]: <!-- CJ In fact, this is the central message of your paper: "We have developed this new workflow, based on four pillars." I would suggest mentioning this very clearly in the opening paragraph. The opening paragraph should at least:
1) Introduce the topic area
2) Introduce the problem/knowledge gap
3) Introduce how you will fill this knowledge gap-->

1. Version control
2. Dynamic document creation
3. Dependency tracking
4. Software management

The remainder of this section briefly explains why each of these four building blocks is needed and their role in ensuring reproducibility.

First, to resolve ambiguity across multiple versions of code and data that come into existence during the development phase of a research project, we recommend using a **version control** system.
Version control allows a clear link between which results were generated by which version of code and data.
A version control system tracks changes to all project-related files (e.g., materials, data, and code) over time.
At a later stage, single files or the entire project can be compared to or reverted to any earlier version.
A version-controlled project makes the loss of files unlikely and also supports remote collaboration.

We recommend using **Git** for version control, because of its widespread adoption in the R community.
Git is built around snapshots that represent the entire project state at a given point in time.
Those snapshots are called "commits" and work like a "save" action.
Changes to files are collected in a _commit_, and each commit has a message that succinctly describes the changes made by the author.
Each commit "knows" its ancestor, and they form a timeline together.
The entirety of commits (i.e. the version-controlled project) is called a repository.
In Git, specific snapshots of a repository can be tagged, such that one can clearly label a given project status as the one that created a given preregistration, a given preprint, or the final authors' version accepted at a journal.
Git has additional features beyond basic version control, such as branches to facilitate collaboration.
@vuorreCuratingResearchAssets2018 provide a more extensive treatment how Git functions and how to use Git.
@bryanExcuseMeYou2018 provides additional information on how to track R Markdown documents.
To collaborate via Git,<!--dangling modify, cant help it--> the repository has to be uploaded somewhere.
We recommend GitHub to host Git repositories because of its popularity among R users.
GitHub has many tools that ease project management and collaboration, and these tools provide much value in our everyday work, but they are not central to achieving reproducibility.

Second, we rely on **dynamic document generation**.
The traditional way of writing a scientific report based on a statistical data analysis uses two separate steps conducted in two different programs.
In a word processor, the researcher writes the text, and in another software, they conduct the analysis.
Typically, results are manually copyied and pasted from one software to the other, a process that often produces inconsistencies [@nuijtenPrevalenceStatisticalReporting2016].

Dynamic document generation integrates both steps. This paradigm can be traced back to @knuthCWEBSystemStructured who suggested that a computer prorgram should be interspersed with explanations of its logic in a natural language. <!--AB I removed the quotation because it is not really clear to me how it matches what we say about R Markdown - I am not sure whether my changes make things better, though-->
**R Markdown** uses Markdown for writing the text and R (or other programming languages) for the analysis.
Markdown is a lightweight text format in plain text with a minimal set of reserved symbols for formatting instructions.
This way, Markdown does not need any specialized software for editing.
It is highly fool-proof (unlike, for example, LaTeX <!--AB citation needed!-->), works well with version control systems, and can be ported to various document formats, such as HTML Websites, a Microsoft Word document, a typeset PDF file (for example, via LaTeX journal templates), or a Powerpoint presentation.
We suggest using Markdown for all sorts of documents that are created in the academic context, starting from simple sketches of your ideas to your scientific manuscripts[@R-rticles], and presentations[@revealjs] or even your rÃ©sumÃ© [@vitae].
R Markdown extends regular Markdown by allowing users to include R code chunks [in fact, arbitrary computer code @riedererChapter15Other] into a Markdown document.
Upon rendering the document, the code blocks are executed, and their output is dynamically inserted into the document.
This allows the creation of (conditionally) formatted text, statistical results, or figures that are guaranteed to be up-to-date because they are created every time anew as the document is rendered to its output format (e.g., presentation slides or a journal article).

One would hope that sharing a literate statistical analysis would allow others (including one own's future self) to simply download and run (ie., reproduce) a given analysis.
However, while version control and dynamic document generation are becoming more common, this approach fails to guarantee reproducibility in most instances [@Peikert2019].
In practice, dependencies between project files (for example, the information what script uses which data file and what script needs to be run first) or on external software (such as system libraries or components of the programming language, such as other R packages) are frequently unmentioned or not exhaustively and unambigously documented.

To automatically resolve dependencies between project files, we rely on **dependency tracking**.
In essence, researchers provide a collection of computational recipes that describe how ingredients are processed to create intermediate products and, in the end, a final product.
Similar to a collection of cooking recipes, we can have multiple products (_targets_) with different ingredients (_requirements_) and different steps of preparation (_recipes_).
In the context of scientific data analysis, the targets are typically the final scientific report (e.g., the one to be submitted to a journal) and possibly intermediate results (such as preprocessed data files, simulation results, analysis results).

We recommend using **Make** for dependency tracking because it is language independent.
To make the utility of Make more concrete, consider the following hypothetical example, in which a research project contains a script to simulate data (`simulate.R`) and a scientific report of the simulation results written in R Markdown (`manuscript.Rmd`).
A Makefile could then look like this:

```{bash, eval=FALSE}
manuscript.pdf: manuscript.Rmd simulated_data.csv
  Rscript -e 'rmarkdown::render("manuscript.Rmd")'

simulated_data.csv: simulate.R
  Rscript -e 'source("simulate.R")'
```

There are two targets, the final rendered report (`manuscript.pdf`, l.1) and the simulation results (`simulation_results.csv`, l.4).
Each target is followed by a colon and a list of requirements.
If a requirement is newer than the target, the recipe will be executed to rebuild the target.
If a requirement does not exist, Make uses a recipe to build the requirement first before building the target.
Here, if one were to build the final `manuscript.pdf` by rendering the R Markdown with the command shown in l.2, Make would make sure that the file `simulation_results.csv` exists; if not, it would find that this is also a target and issue the command in l.5 to run the simulation first before rendering the manuscript.
This way, we ensure that the simulation is always run before the manuscript is built and that the manuscript is rebuilt if the simulation code was changed.
Make therefore offers a standardized process to reproduce projects, regardless of the complexity or configuration of the project.

```{r, include=FALSE}
container_size <- as.numeric(fs::file_size("reprotutorial.sif"))/1024^3
```

A version controlled dynamic document with dependency tracking may still rely on external software.
Troubleshooting issues specific to a particular programming language or dependent tool typically requires considerable expertise and pose a threat to reproducibility.
One solution to avoid problems caused by missing or inconsistent external software dependencies is to provide not only the analysis script but all dependent software packages and system libraries via **software management**.
One comprehensive approach to software management is containerization.
"By packaging the key elements of the computational  environment  needed  to  run  the  desired  software, [...] they  make the software much easier to use, and the results easier to reproduce [@silverSoftwareSimplified2017]. <!--AB: direct quotes need a line number! See APA style guide-->
Instead of leaving it to the user which software should be installed how on their computer, **Docker** provides all software used in an analysis, including the operating system itself.
The operating system level is important because some functionality may be passed to software layers beneath the programming language, such as calls to random number generators, linear algebra libraries and such.
Docker does this without interfering with the already installed software by using a virtual software environment independent of the host software environment.
Researchers therefore have the opportunity to use the exact same software setup that was used by the original authors.
Such a snapshot of the software stack is called an "image".
Packaging all required software in such an image requires considerable amounts of storage space.
Two major strategies help to keep the storage requirements reasonable.
First, there is a community that maintains pre-made images for particular purposes.
For example, there are pre-made images that only include what is necessary for R, based on Ubuntu (a Linux operating system) containers [@boettigerIntroductionRockerDocker2017].
Users can then install whatever they need in addition to what is provided by these pre-compiled images.
`r ifelse(is.na(container_size), "", glue::glue("The image that was used for this article uses {round(container_size, 2)}Gb of disk space."))`
Our image includes Ubuntu, R, R Studio, LaTeX as well as a variety of R packages like the tidyverse [@tidyverse] and all their dependent packages, amounting to `r installed.packages() %>% as.data.frame() %>% filter(is.na(Priority)) %>% nrow()` R packages.
Second, instead of saving a binary image of the software environment, one can also save a container recipe, a so-called  `Dockerfile`.
This recipe is a textual description of all commands that need to be executed to recreate the image.
Such files are tiny (the [Dockerfile](https://github.com/aaronpeikert/repro-tutorial/blob/main/Dockerfile) for this project has a size of only `r round(as.numeric(fs::file_size("Dockerfile"))/1024^1, 2)`Kb) and sufficiently describes how to recreate a given container image.
However, Dockerfiles rely on the assumption that all software repositories that provide the dependent operating systems, pieces of software, and R packages will remain accessible in future and will continue to make available historic software versions.
For proper archival, we therefore recommend to keep a full image in addition to the Dockerfile.
A more comprehensive overview of the use of containarization in research projects is given by @wiebelsLeveragingContainersReproducible2021.

To summarize, the workflow by @Peikert2019 requires four components (see Figure \@ref(fig:schematic)), dynamic document generation (using R Markdown), version control (using Git), internal dependency management (using Make), and containerization (using Docker).
While R Markdown and Git are well integrated into the R environment through R Studio, Make and Docker require a level of expertise that is often beyond the training of scholars outside studies of information technology, which can represent a considerable hurdle in the acceptance and implementation of the workflow.
To remove this hurdle, we have developed a new R package `repro` that supports scholars in setting up, maintaining, and reproducing research projects in R.
In the remainder, we will walk you through the creation of a reproducible research project with the package `repro`.

```{r schematic, eval = TRUE, echo = FALSE, fig.cap="Schematic illustration of the interplay of the four components (in dashed boxes) central to the reproducible workflow: version control (Git), dependency tracking (Make), software management (Docker), and dynamic document generation (R Markdown). Git tracks changes to the project over time. Make manages dependencies among the files. Docker provides a container in which the final report is built using dynamic document generation in R Markdown. Reproduced from @Peikert2019.  "}
# file gets downloaded in Makefile
knitr::include_graphics(here::here("images/nutshell.svg"), auto_pdf = TRUE)
```

# Creating reproducible research projects

A major barrier to adoption of the above tools for researchers is that they are typically used via a command line interface (CLI).
The CLI predates and coexists with graphical user interfaces (GUIs), which many users (including the authors) prefer over the text-based interactions of a CLI for most tasks.
A GUI has the apparent disadvantage for reproducibility that it requires a user who clicks on the correct elements (such as buttons or menu items) in the correct order.<!--AB not sure about the entire paragraph about CLI vs GUI here -  can we shorten this entire paragraph?-->
Depending on the number of steps taken, this is not only much effort but also error-prone.
This tutorial seeks a compromise.
We use simple GUI actions to create a reproducible workflow template, but the reproduction of such workflow does not rely on manual steps. <!--AB I modified this sentence - but I am not sure what we are saying here with the "manual steps"-->
At several points, we rely on or have developed a CLI that wraps a more complicated (and powerful) CLI.
These wrappers use standard CLI tools but provide feedback for the user about what the computer does and what the user should do in layman's terms and are accessible from within R.
We hope this makes reproducibility tools more accessible by enabling beginner-level users to detect their systems state accurately and act correspondingly [@parasuramanAutomationHumanPerformance2018, Chapter 8: "Automation and Situation Awareness"].
These alternative tools are merely an assistance system, and as users get more and more comfortable, they can use the underlying tools directly to solve more complex problems.

Before we can start creating reproducible research projects, we need a computer with a working R Studio installation. 
Start R Studio and install the package [`repro`](https://github.com/aaronpeikert)[@R-repro] so that it can act as an assistance systems while you follow the tutorial:

```{r, eval=FALSE}
# repro is not on CRAN yet
install.packages('repro', repos = 'https://aaronpeikert.r-universe.dev')
```

An example of the assistance that `repro` provides are the check functions.
They verify that you indeed have installed and setup the required pieces of software for this workflow (here, we use the double-colon operator to access functions from the `repro` namespace; we chose to do so to make clear which functions are native `repro` functions) :

```{r}
repro::check_git()
repro::check_make()
repro::check_docker()
```

They detect the users' system state and explain if further action is needed.
Sometimes they ask the user to do something, for example, the following happens if you were a Windows user who does not have Git installed:

```{r, include=FALSE}
opts <- options()
options(repro.os = "windows",
        repro.git = FALSE)
```

```{r}
check_git()
```

```{r, include=FALSE}
options(opts)
```

The messages emitted by `repro` and other packages we present try to take the user by the hand to help them solve problems.
This tutorial describes steps that we expect to apply to all users; the messages from the packages are adjusted to your specific situation (that is, operating system and the specific problem of missing software) and complement the tutorial in this way.
Before you continue, we ask you to run the above commands to check Git, Make, and Docker.
If necessary, follow the instructions of repro to install them until the check functions are all fine.

The first concept we want to introduce is version control with Git.
Git tracks files within one project folder.
We start by creating such a project folder with RStudio by clicking the menu item:

> File â†’ New Project... â†’ New Directory â†’ Example Repro Template

This creates a project containing an example analysis, but you may use any other template or existing R Project to turn into a reproducible research project using the functionality of `repro`.

You can prevent Git from accidentally committing files that you do not want to track with the `.gitignore` file.
You can add something to the `.gitignore` file directly or with this command:

```{r, eval=FALSE}
usethis::use_git_ignore("private.md")
```

Now the file `private.md` will not be committed to Git and will not be made public.

After you have excluded sensitive files (like not yet anonymized data files), you can activate Git with:

```{r, eval=FALSE}
usethis::use_git()
```

Whenever you made changes to a given file, you have to stage and then commit these changes (this is the basic save action for a project snapshot).
The easiest way to do this is to use the RStudio Git pane.
Click on the empty box next to the file you want to stage, and when a tick appears, which means that the file is staged.
After you have staged all files you want, click on the commit button, explain in the commit message why you made those changes, and then click on commit.

The files you created and the changes you made still have not left your computer.
All snapshots are stored in a local repository in your project folder.
To back up and share the files, you can publicly upload those changes to a public repository. To synchronize your local repository with a remote repository from the GitHub service, issue the following command:

```{r, eval=FALSE}
usethis::use_github()
```

Depending on your computer configuration, this may ask to set up a secure connection to GitHub. In this case first follow the suggestions shown on the command line.

If you are not yet ready to share your project publicly but you want to synchronize your local repository to a remote repository (for example, as a simple backup service), use:

```{r, eval=FALSE}
usethis::use_github(private = TRUE)
```

Now that you have created a project that is under version control, we continue with adding dynamic document generation.
Adynamic document has three elements:

1. Text in a natural language
2. Executable code 
3. Metadata

The text of an R Markdown is written in Markdown. <!--AB citation needed for further information-->
The following Markdown example serves to illustrate the Markdown syntax. 
It shows how to create a heading, a word in bold font, and a list of several items in Markdown:

```markdown
<!--this is a Markdown file -->
# Heading (level 1)

Normal text.
Important **word** in bold.

## Subheading (level 2)

To do list:

* do research
* do more research
* spend time with family and friends
```

This type of markup for formatting, instead of the more visual approach of e.g. Microsoft Word, is compatible with many output formats and is easier to put under version control.
Some users might find it easier to activate the "Visual Editor" of R Studio (Ctrl + Shift + F4 or click on the icon that resembles drawing materials or a compass in the upper right corner of the R Markdown document) which features more graphical elements like a traditional word processor but still creates an R Markdown underneath with all of its flexibility.
The visual editor has the additional benefit of promoting best practices (for example, each sentence should be written on a newline, which eases tracking changes across versions). Among other features, it eases the generation of citations and cross references.

Now that you are familiar with the basics of writing text in Markdown, we turn our attention to including code into the text.
Code is separated by three backticks (and the programming language in curly braces) like here:

````markdown
This is normal text, written in Markdown.

`r ''````{r}
# this is R code
1 + 1
```
````

Now that you know how to write text and R code in an R Markdown, you need to know about metadata, like the title or the output format. Metadata are placed at the beginning of the document and are separated by three dashes from the document body; the following example is a full markdown document where the header is in lines 1--6.

````markdown
---
title: A Hitchhiker's Guide to Reproducible Research in R
author: Aaron Peikert, Caspar J. Van Lissa and Andreas M. Brandmaier
abstract: A tutorial about doing the same thing more than once.
output: html_document
---

# Introduction

Important for reproducibility:

1. Version Control
2. Dynamic Document Creation
3. Dependency Tracking
4. Software Management

`r ''````{r}
# this is R code
t.test(extra ~ group, data = sleep)
```
````

Most metadata fields are self-explanatory (like the author field). 
Sometimes, R package may extend the metadata fields for their own purposes.
Certain output formats may require specific  metadata. 
For example, the `rticles`-package that offers templates for authoring scientific manuscripts comes with extra fields that are described in the package documentation and offer extra options for flexible formatting of documents.
R Markdown has been extended to hundreds of document formats which are often highly configurable by their metadata.
The `repro` package uses the metadata for hints to make the research project reproducible.
Researchers should list all dependent resources of their research project in the metadata, that is, R scripts, data files, and external packages in the following format (see everything below the line *repro:*):

```markdown
---
title: A Hitchhiker's Guide to Reproducible Research in R
author: Aaron Peikert, Caspar J. Van Lissa and Andreas M. Brandmaier
abstract: A paper about recalculating the same thing more than once.
output: html_document
repro:
  scripts:
    - R/load.R
  data:
    - data/mtcars.csv
  packages:
    - tidyverse
    - usethis
    - gert
---
```

This information makes internal dependencies to other files in the project and external dependencies to R packages explicit.
`repro` can use this information to infer a Makefile for the dependencies on other files and a Dockerfile that includes all required packages.
These two files together form the basis for consistency within a research project and consistency across different systems.
At this point, we would like to emphasize that a preqrequisite for reproducibility is that every step taken in an analysis can be automatically reproduced.
This means there must be no manual processing such as copy and pasting, manual modification of data files (e.g., manually removing observations or manually recoding variables). 
Ideally, all data preprocessing is well-documented and gathered in a separate R file, which is then called before a Markdown report is generated (that is, the preprocessing script is added in the metadata header under _scripts:_).
In everyday work, the simplest solution is to now call the function `repro::automate()` which both creates a Makefile and a Dockerfile from all R Markdown files in the project (all files with the ending `.Rmd`) based on the respective repro metadata entries.
Every time you change the `repro`-metadata, change the output format, or add a new R Markdown file to the project, the Makefile and Dockerfile are potentially outdated, and you should run `repro::automate()` to keep them up to date.
The function `repro::automate()` does not overwrite manual changes, and there is no harm in running it too often.
Other than the Makefile and the Dockerfile, which are created in the document root path, repro generates a few more files in the `.repro` directory (which we will explain in detail later), all of which you should add and commit to Git. <!--AB: why is this addition not automated? Feels strange given that this is our recommended best practice?!-->

When you or someone else who received your project want to reproduce it, they can ask repro to explain how this should be done:

```{r}
repro::rerun()
```
<!--AB: I still think this should be repro::reproduce() please change!-->
Importantly, a reproducible research project created with `repro` does not have the `repro` package itself as a dependency.
These projects will remain reproducible irrespective of whether `repro` will be maintained and remain accessible in future.
Users do not have to have repro installed to reproduce a project, in fact, they do not even need to have R installed because the entire project can be rebuilt inside of a container that has R installed. 
The two Make commands `make docker` and `make -B DOCKER=TRUE` together with an installation of Make and Docker are sufficient.
The commands can be pasted into a terminal and will reproduce the project in many cases.
<!--AB: I said this before. I think it really should be possible to execute this command from within R. Never underestimate the troubles people can have with the terminal. I think we discussed this before. Please add a function repro::rerun(execute=TRUE) or -- if we rename it -- repro::reproduce(execute=TRUE). -->

# Advanced Features

Some projects, however, are not as easy to make reproducible.
As explained above, repro is merely a simplified interface that guarantuees a high level of reproducibility for simple projects.
These simplifications are possible because of two restrictions.
First, the project can only rely on R packages for the Dockerfile and second, it can have no multilayered preprocessing for the Makefile.<!--AB: please explain both points in more detail-->
Lifting these restrictions requires the user to interact more directly with Make or Docker.
To satisfy more complicated requirements users need to understand how repro utilizes Make and Docker internally.

Let us have a closer look at the command for reproducing a repro project: `make docker && make -B DOCKER=TRUE`; it consists of two processing steps.
First it recreates the virtual software environment (Docker) and then it executes computational recipes in the virtual software environment (Make).
The first step is done by the command `make docker`.
The command `make docker` will trigger Make to build the target called `docker`.
The recipe for this target builds an image from the Dockerfile of the repository.
The `&&` concatenates both commands and only runs the second command if the first was successful.
Therefore, the computational steps are only executed when the software environment is set up.
The second step executes the actual reproduction and is again a call to Make in the form of `make -B DOCKER=TRUE` with three noteworthy parts.
First, a call to `make` without any explicit target will build the Make target `all`.
Second, the flag `-B` means that Make will consider all dependencies as outdated and hence will rebuild everything.
Third, repro constructs Make targets so that if you supply `DOCKER=TRUE` they are executed within the Docker image of the project.

This interplay between Docker and Make is relatively complicated because it resembles a chicken or egg problem.
We have computational steps (Make) which depend on the software environment (Docker) for which we again have computational steps that create it.
Users only require a deeper understanding of this interdependence when they either want to have more complex computational recipes than rendering an R Markdown or require other software than R packages.

Users can have full control over the software installed within the image of the project.
`repro` creates three Dockerfiles inside the `.repro` directory.
The file `.repro/Dockerfile_base` contains information about the base image on which all the remaining software is installed.
By default we rely on the "verse" images provided by the Rocker project [@boettigerIntroductionRockerDocker2017].
These contain (among other things) the packages `tidyverse`, `rmarkdown` and a complete LaTeX installation, which makes these images ideal for the creation of scientific manuscripts.
Users can choose which R version they want to have inside the container by changing the version number in line 1 to the desired R version number.
By default the R version corresponds to the locally installed <!--AB: please check - did I get this correctly? It is the local version?-->version on which `repro::automate()` was called the first time.
The build date is used to install packages in the version which was available on CRAN on this specific date and can also be changed, by default this date is set to the date on which `repro::automate()` was called the first time. 
This way, the call to the automate function virtually freezes the R environment to the state it was called the first time inside the container. 
Below, you see the Docker base file we used to create this manuscript:

```{r, results='asis', echo=FALSE}
cat(
  "```bash",
  readLines(here::here(".repro", "Dockerfile_base"))[1:3],
  "```",
  sep = "\n"
)
```

The file `.repro/Dockerfile_manual` is empty by default and can be used to add further dependencies outside of R, like system libraries or external software. 
Remember, the software environment of the Docker image is completely separate from software installed on your computer.
This separation is excellent for reproducibility, but requires you to install software on an operating system that may not be familiar to you.
The images supplied by [@boettigerIntroductionRockerDocker2017] are based on Ubuntu, and hence software has to be installed in a way that is compatible with Ubuntu.
The most convenient way to install software on Ubuntu is through its package manager `apt`.
The following snipped installs Python.
If added to `.repro/Dockerfile_manual` the Docker image will have Python installed.

```bash
RUN apt-get update && apt-get install -y python3
```

The last Dockerfile, `.repro/Dockerfile_packages`, is automatically generated from the metadata provided and must not be manually changed.
Whenever `repro::automate()` is called, repro gathers all R packages from all `.Rmd` files and figures out whether they should be installed from CRAN or GitHub. <!-- does this also figure out the specific version? If so, please say so-->

The separation into several Dockerfiles is a design choice to provide a clear separation between automatically generated parts based on metadata provided and manually altered parts of the Dockerfile.
Docker eventually requires a single Dockerfile to run, so `repro::automate()` simply concatenates the three Dockerfiles and saves the result into the main `Dockerfile` at the top level of the R project.

With this approach, users of `repro` can not only build complex software environments but they can also implement complex file dependencies.
The standard `repro` metadata only makes sure that all dependencies are available but does not allow you to specify custom recipes for them in the metadata.
If you can formulate the creation of dependencies in terms of computational steps you should include these in the Makefile.<!--AB I do not understand this sentence-->
The Makefile that `repro` creates is only an template and you are free to change it.
However, make sure to never remove the following two lines:

```bash
include .repro/Makefile_Rmds
include .repro/Makefile_Docker
```

The file `.repro/Makefile_Rmds` contains the automatically generated targets from `repro::automate()` for the R Markdown files.
This file should not be altered manually.
If you want to adept<!--AB strange word?! change--> a target than simply provide an alternative target in the main `Makefile`.
Targets in the main `Makefile` take precedent.

The file `.repro/Makefile_Docker` does again contain a rather complicated template which you could but usually should not modify.
This Makefile coordinates the interplay between Make and Docker and contains targets for building (with `make docker`) and saving (with `make save-docker`) the Docker image.
Additionally, it provides facilities to execute commands within the container.
If you write computational recipe for a target it will be by default evaluated using the locally installed software.
To instead evaluate commands inside the Docker image, you should wrap them in `$(RUN1) command $(RUN2)`, like in this example:<!--AB please explain this hypothetical example in more detail, so that we can follow along-->

```bash
simulated_data.csv: R/simulate.R
  $(RUN1) Rscript -e 'source("R/simulate.R")' $(RUN1)
```

If users execute this in the terminal

```bash
make simulated_data.csv
```

this is simply translated to:

```{r, echo=FALSE, results='asis'}
cat("```bash",
  stringi::stri_wrap(system2("make", " --dry-run simulated_data.csv", stdout = TRUE)),
  "```", sep = "\n")
```

But if users use

```bash
make DOCKER=TRUE simulated_data.csv
```

it is evaluated within the Docker container:

```{r, echo=FALSE, results='asis'}
cat("```bash",
  stringi::stri_wrap(system2("make", " --dry-run DOCKER=TRUE simulated_data.csv", stdout = TRUE)),
  "```", sep = "\n")
```

To summarise, `repro` provides researchers with an easy to use solution for dependency tracking (in form of Make) and software management (using Docker) without the necessity to learn both languages.
Users with more advanced requirements can manually change all aspects of both programs while still profiting from `repro`'s automations.

# Introducing Preregistration as Code 

We argue that a preregistration as code (PAC) is an excellent planning tool that offers several benefits over traditional preregistration.
For a PAC, researchers write a reproducible, dynamically generated manuscript including the sections Introduction, Methods, and Results before they gather data, were the results are initially based on simulated data.
We discuss PAC as an example of how a robust reproducibility standard has the potential to benefit research projects throughout the whole research process, starting at the beginning, with planning a study.

We consider three criteria when planning a study.
First, the plan should be comprehensive, e.g. state the research question and describe the study design and analysis.
Second, the plan should be effective, meaning that the researchers can reasonably expect it to answer the research question at hand.
Third, the plan should be efficient; therefore, it only employs the necessary amount of resources.

To ensure a comprehensive plan, we suggest that researchers borrow from widely employed standards for writing an empirical manuscript [e.g. @apa7].
The introduction and theoretical background provide the basis for the studies' design and can be written before gathering data.
We argue that researchers can plan more effectively if they formulate the planned analysis as a method section that again follows best practices for describing empirical research.
To ensure that the analysis is technically feasible, they can translate their method section into executable computer code for the data analysis using simulated data.
The researchers can include a "faked" results section based on the simulated data, employing dynamic document generation.

Repeated simulation with varying parameters, a so-called Monte Carlo simulation, can then be employed to plan resources to assure efficiency.
For example, researchers can assess the power (the probability to detect an effect of a given size) for varying numbers of observations in the simulation to determine the required sample size for their study.
While rather uncommon for an empirical research project, we argue that simulating data offers various benefits in the planning phase of a study.
First, you have to address and could plan for data analytic problems on a conceptual level before you made the considerable effort to acquire data [@axelrodAdvancingArtSimulation1997].
Second, if you only simulate a single dataset, you can perform a simple technical check, that is the analysis software outputs parameter estimates [@braiekTestingMachineLearning2020], e.g. when the simulated data contains missings.
Third, if you perform a Monte Carlo simulation, you may evaluate how the data analysis copes with expected data complications, e.g. non-normal data [@harrisonIntroductionMonteCarlo2010; @raychaudhuriIntroductionMonteCarlo2008].
Fourth, you can plan your resources efficiently, e.g. determine required sample size to achieve certain precision or power [@brandmaier2018precision].
@bakkerRecommendationsPreregistrationsInternal2020 found that a formal power analysis does not necessarily increase the planned sample size.

Defining the research questions and planning data analysis before observing the research outcomes is called preregistration [@NosekRevolution2018].
Preregistration increases the credibility of empirical results in three ways, @nosekPreregistrationHardWorthwhile2019:

> First, preregistration of analysis plans makes clear which analyses were planned a priori and which were conducted post hoc. This improves calibration of uncertainty for unplanned analyses, and diagnosticity of statistical inferences for planned analyses. [...] Doing so has the benefit of strengthening statistical inferences as compared with unplanned analyses. [...] Second, preregistration enables detection of questionable research practices such as selective outcome reporting (John et al. 2012) or Hypothesizing After the Results are Known (HARKing; Kerr, 1998). Third, preregistration of studies can reduce the impact of publication biasâ€”particularly the prioritization of publishing positive over negative resultsâ€”by making all planned studies discoverable whether or not they are ultimately published.

The idea of submitting code as part of a preregistration is not new.
A prominent preregistration platform, [The Open Science Framework](https://osf.io/), suggests submitting scripts alongside the preregistration of methods and in an informal literature research (we skimmed the first 300 results with the keywords `("pre registration"|"pre-registration"|preregistration)&(code|script|matlab|python|"R")`) we have found close to a dozen published articles which did included some form of script as part of their preregistration.

Why are PAC and reproducibility related?
Preregistrations are plagued by nonreproducibility like any other research outcome.
@bakkerRecommendationsPreregistrationsInternal2020 found from the 210 preregistrations they investigated 174 (67%) included a formal power analysis but from these only 34 (20%) provided enough information to theoretically reproduce the power analysis.
Even researcher who have gone to great length in submitting a script in their preregistration sometimes inexplicably fail to reproduce their own results.
@steegenMeasuringCrowdAgain2014 realized after publication that part of their preregistered code results in different test statistic than they reported initially (see Footnote 7).

We believe that pairing PAC with the here presented workflow offers five advantages over classical preregistration.
First, a PAC removes any ambiguity regarding the translation of an analysis plan into code.
Even when several researchers describe their analysis with the same terms, use the same data, and investigate the same hypothesis the results vary considerably [@silberzahnManyAnalystsOne2018].
Second, despite being rigorous, it offers the flexibility to incorporate data-dependent decisions if they can be formulated as code.
Researchers can, for example, formulate conditions under which they prefer one analysis over the other, i.e. if distributional assumptions are not met, employ robust methods or automated variable selection mechanisms.
Third, a PAC more comprehensive is by design because e.g. missing steps are obvious when the code is tested on simulated data.
A due to its high structure PAC can therefore more effectively minimize researchers degrees of freedom than a standard preregistration [@bakkerEnsuringQualitySpecificity2020].
Forth, deviations from the preregistration are more explicit because they are reflected in changes to the code, a property facilitated by version control.
Fiveth, the preregistration is merely a development stage of the final manuscript, thus saving the researchers from writing and the reviewer from evaluating two separate documents.

PACs come with a challange though, in contrast to a reproducible script, that should work on the same data, a PAC must function on different data.
We call this property "reusability".
This property is based on reproducibility, but requires the researcher to more carefully write the software [@lanerganSoftwareEngineeringReusable1989] so it is build-for-reuse [@al-badareenReusableSoftwareComponents2010].
The reproducible workflow we present here is heavily automated and hence promotes reusibility.
Increased automation is more and more recognized as a means to improve the research process [@rouderMinimizingMistakesPsychological2019] and therefore this workflow fits well together with other innovations that employ automation, like machine readible hypothethis tests [@lakensImprovingTransparencyFalsifiability2021] or automated data documentation [@arslanHowAutomaticallyDocument2019].
Automated and reusable research projects promises a wide range of applications, among them PAC [possibly submitted as a registered report @nosekRegisteredReports2014; @chambersWhatNextRegistered2019], Direct Replication[@simonsValueDirectReplication2014], fully automated living metanalysis [@elliottLivingSystematicReviews2014], Executable Research Articles [@elifesciencespublicationsELifeLaunchesExecutable2020], and other innovations like the live analysis of born open data [@rouderWhatWhyHow2016; @kekecsRaisingValueResearch2019].

Therefore reproducibility facilitates traditional good scientific practices and provides the fundament for promising innovations.

# Preregistration as Code --- a Tutorial

To guide the reader through a preregistration as code (PAC), we will use an exemplary research question:

> "Is there a mean difference in the personality trait 'Machiavellism' between self identified females and males?"

This example serves only didactic purposes and not to derive substantive claims.
Nevertheless, everything else is kept as close to a real research question as possible.

At the heart of a PAC lies the planned analysis.
We suggest writing a function that captures the full process of testing a research question that receives a dataset as input.
For the hypothetical research question, we could for example plan to conduct a simple Student's t-test [@studentProbableErrorMean1908] with Welch's correction [@welchGeneralizationStudentProblem1947] an the average of machiavillism items of the Short Dard Triad [SD3, @Jones2013] between the gender groups.
As an example of a data dependent decisions we included a rank transformation if the skewness greater than 1, converting the t-test to a supposedly more robust Mannâ€“Whitneyâ€“Wilcoxon test.[^caution-mww]

[^caution-mww]: The Mannâ€“Whitneyâ€“Wilcoxon is **not** more robust than the Welch corrected t-test for reasonably large sample sizes. The interested reader can use the provided code for the simulation to verify that the t-test provides unbiased effect sizes but the Mannâ€“Whitneyâ€“Wilcoxon overestimates effect size with increasing sample size and skewness.

This function is one possible translation of the verbal descriptions:

```{r planned_analysis}
```

One point of note about the analytical strategy and the function implementing it is that there are several translations into code that would fit the descriptions but would produce different results.
One example would be using the function `wilcox.test` instead of the combinations of `rank` and `t.test`.
Both are valid implementation of Mannâ€“Whitneyâ€“Wilcoxon test but the first assumes equal variance while the second applies Welch's correction and hence is robust even with unequal variances [@zimmermanRankTransformationsPower1993].
Mentioning every such minute implementation detail is would result in overly verbose preregistrations but does change the outcome.

We also want to caution researchers to not use the here shown procedure.
We merely choose it for didactic purposes because it may be familiar to many researchers because the t-test and Mannâ€“Whitneyâ€“Wilcoxon test are arguably the most often used hypothesis test [@fagerlandTtestsNonparametricTests2012; @hortonStatisticalMethodsJournal2005 reports that 26% of all studies employ a t-test and 27% employ a rank based alternative in the New England Journal of Medicine in 2005].
This analytical strategie is suboptimal with regard to several criteria (untested assumption of measurement invariance [@putnickMeasurementInvarianceConventions2016], underestimation of effect size in presence of measurement error [@frostCorrectingRegressionDilution2000], overestimation of effect size for highly skewed distributions [@stonehouseRobustnessTestsCombined1998]); 

To use this function one needs a compatible dataset.
At the time of preregistration there is of course no actual data available.
We therefore simulate a dataset.

```{r simulate_data}
```

We decided to draw non-normal data to test how well our procedure performed under non-optimal situations.
Specifically, we draw from a $\chi^2$-distribution, where in one group we add difference that conforms to a standardized effect size.
This simulated dataset fits perfectly into our planned analysis:

***

```{r}
set.seed(112358) # fix state of RNG
results <- 
  planned_analysis(
    simulate_data(
      n = 400,# Sample size
      df = 8, # Chisq with DF = 8 has skewness = 1
      d = .2, # Cohen's D
      i = 10  # Number of items (should not effect anything)
    )
  )
```

These results are based on simulated data:

```{r, results='asis'}
report::report(results$test)
```

***

```{r, echo=FALSE}
res <-
  read_csv(here::here("data", "simulation_results.csv"), col_types = "ddddddd")
choosen_power <- .8
choosen_d <- .2
minn <- filter(res, d == choosen_d, power > choosen_power) %>% 
  filter(n == min(n))
```

To determine a minimal sample size for this study we repeat this simulation across several combination of effect sizes and sample sizes.
One standard recomendations for choosing a sample size is to have an expected power of 80% based on the expected effect size.
@Jones2013 found in three studies gender differences of .24, .29, and .35 for their machiavilism subscale.
If we want to detect an effect of size `r choosen_d` with an `r choosen_power*100`% probability, our simulation shows that we require at least `r minn$n` participants.

```{r, echo=FALSE}
res %>%
  ggplot(aes(n, power, color = d, group = d)) +
  geom_line() +
  geom_point(
    data = minn,
    size = 3,
    color = "black",
    shape = 3
  ) +
  theme_minimal() +
  scale_color_viridis_c() +
  theme(legend.title = element_text()) +
  labs(y = "Power\n(Proportion of significant results)",
       x = "Sample size",
       color = "Cohen's D") +
  NULL
```

# References

```{r, include=FALSE}
knitr::write_bib(
  c(
    .packages(),
    "repro",
    "here",
    "rticles",
    "gert",
    "bookdown",
    "lavaan",
    "knitr",
    "targets",
    "renv",
    "tidyverse"
  ),
  here("packages.bib")
)
cat(c(readLines(here::here("packages.bib")), "\n", readLines(here::here("references.bib"))), sep = "\n", file = "temp.bib")
```
